# 23 - 垃圾回收机制

在JavaScript 中，字符串、对象、数组等数据的占用内存时不固定的，只有在实际使用的时候才会动态分配内存。
当这些数据占用的内存不在使用时，需要释放出来重新使用，如果不及时回收轻将会拖慢程序运行，当可用内存耗尽时，程序将崩溃，也就是所谓的内存泄露。所以垃圾回收非常必要！

## 是什么

预防内存泄漏，JavaScript 回收这些没用地数据地过程被称为垃圾回收。

垃圾回收机制也成为垃圾收集，简称GC（**Garbage Collection**）。

> JavaScript 中的垃圾回收是自动的 ，通过一些收集算法，找到不再使用的变量或属性并清理（即减少内存开销），JavaScript 引擎以固定的时间间隔周期性地释放内存空间（在C/C++ 中，程序员需要手动完成垃圾回收）

自动内存管理（垃圾回收）：
- JavaScript
- Java
- Go
- Python
- PHP
- Ruby
- C#

手动内存管理：
- C
- C++
- Rust

## 什么是内存泄漏

程序的运行需要占用内存，当这些程序没有用到时，还不释放内存，就会引起内存泄漏。举个通俗的例子，就好比占着茅坑不拉屎，坑位（内存量）就这么多，你还不出去（释放内存），就会引起想拉的人不能拉（系统变卡，严重点的会引起进程崩溃）

也就是说不再用到的内存，没有及时释放，就被称为内存泄漏。而内存泄漏，会让系统占用极高的内存，让系统变卡甚至奔溃。

## 回收的是什么

内存（清理变量，释放内存空间）

## 为什么会有内存回收

如果任由内存泄漏，会让系统变卡甚至崩溃。

导致这些问题地原因是JavaScript 地引擎V8 只能使用一部分内存，具体来说：
- 在64位系统下，最多只能分配 1.4G
- 在32位系统下，最多只能分配 0.7G

因为使用内存大小上限，所以当又用不到变量时，引擎会帮我们清理掉

## 垃圾回收地运行机制

JavaScript 的数据类型可分为基本类型和引用类型。基本类型存在栈内存，引用类型存在堆内存

基本类型花销的内存小，而引用类型花销的内存大，而这恰恰是分两个空间存放不同数据的原因

在JavaScript 中，引擎需要用栈来维护程序执行时的上下文状态（即执行上下文），如果栈空间大了的话，所有数据存放在栈空间中，会影响到上下文切换的效率，从而影响整个程序的执行效率，所以占内存大的数据会放在堆空间中，引用它的地址来表示这个变量

## 堆内存的分类

一个V8 进程的内存通常由以下部分组成

- 新生代内存区（new space）
- 老生代内存区（old space）
- 大对象区（large object space）
- 代码区（code space）
- map区（map space）

## 新生代与老生代的垃圾回收

代际假说
- 大部分对象在内存中存活的时间很短，简单说，就是很对对象一经分配内存，很快就变得不可访问
- 不死的对象，会活的很久

因为有代际假说的认知，所以我们在垃圾回收时，会根据对象不同的生存周期采用不同的算法，其中V8 把堆内存分为新生代和老生代两个区域（其他几个区域用处不大），即分代回收

> 新生代中存放生存时间短的对象，老生代存放生存时间久的对象

为此，新生代区通常只支持1-8M 的容量，而老生代区会支持更大的容量，而针对这两块区域，V8 分别使用两个不同的垃圾回收器

- 主垃圾回收器，负责老生代的垃圾回收
- 副垃圾回收器，负责新生代的垃圾回收

### 新生代内存回收

采用Scavenge 算法
- 把新生代空间对半分为两个区域
  - 对象区域（from）
  - 空闲区域（to）

![V8 堆内存](/static/v2-5d90683202ee91166024cef4e158f5b5_r.jpg)

新的对象会首先被分配到对象（from）空间，当对象区域快写满时，就需要执行一次垃圾清理操作。当进行垃圾回收时，先将from 空间中存活的对象复制到空闲（to）空间进行保存，对未存活的空间进行回收。复制完成后，对象空间和空闲空间进行角色对换，空闲空间编程新的对象空间，原来的对象空间则变成空闲空间。这样就完成了垃圾对象的回收操作，同时这种角色调换的操作能让新生代中的这两块区域无限重复使用下去

![Scavenge 算法执行示意图](/static/v2-ba1ae480cc0a1382e0b607ba92cabe75_r.jpg)

而当一个对象在两次变换中还存在时，就会从新生代区”晋升“到”老生代区“。这一过程被称为对象晋升策略

### 老生代内存回收

主垃圾回收器负责老生代区的垃圾回收。其中的对象包括新生代区”晋升“的对象和一些大的对象。因此老生代区中的对象有两个特点，对象占用空间大，对象存活时间长

它不会像新生代区那样使用 Scavenge 算法，因为复制大的对象所花费的时间长，执行效率并不高。所以它采用标记 - 清除（Mark - Sweep）进行垃圾回收

简单来说，先标记，然后清除，但是内存空间里的对象还是不连续，所以引入整理。这就是老生代区的垃圾回收过程 标记 - 清除 - 整理。先标记哪些是要回收的变量，再进行回收（清除），然后将内存空间整理（到一边），这样空间就大了

![标记整理过程](/static/v2-33f352d7ded14073b6fbf83a8b90dad5_r.jpg)

因为老生代区的对象相对大，虽然采用”标记-清除“算法会比 Scavenge 更快，但架不住卡顿问题。为什么会卡顿？因为 JavaScript 是单线程。为此，V8 将标记过程分为一个个子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，这一算法被称为增量标记算法

![标记整理过程](/static/v2-8caeb00451623c091f96f52e824da166_r.jpg)

而这一行为，与 React Fiber 的设计思路类似，将大任务分割成小任务，因为小，所以执行快，让人察觉不到卡顿

### 新生代 VS 老生代

- 新生代垃圾回收是临时分配的内存，存活时间短；老生代垃圾回收是常驻内存，存活时间长
- 新生代垃圾回收由副垃圾回收器负责；老生代垃圾回收由主垃圾回收器负责
- 新生代采用 Scavenge 算法；老生代采用「标记-清除」算法
  - Scavenge 算法：将空间分为两半，一半是 from 空间，一半是 to 空间。新加入的对象会放在 from 空间，当空间快满时，执行垃圾清理；再角色调换，再当调换完后的 from 空间快蛮时，再执行垃圾清理，如此反复
  - 标记-清理-整理：此为两个算法，「标记-清理」算法和 「标记-整理」算法
    - 标记-清理：标记用不到的变量，清理掉
    - 标记-整理：清理完内存后，会产生不连续的内存空间，为节省空间，整理算法会将内存排序到一处空间，空间就变大了

## 引用计数（reference counting）(被放弃了)

> 《JavaScript 高级程序设计》:引用计数

简单来说：引擎会有张”引用表“，保存了内存里面的资源的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放

但后来这个机制被放弃了，因为它会遇到一个严重的问题：循环引用，从而导致内存泄漏，所以被放弃了

## 编年体垃圾回收历史

- 1960年，John McCarthy发表了一篇论文，提出了标记-清除算法
  - 标记-清除算法由两个要命的缺点
    - 分配速度慢
    - 容易产生碎片
- 1963年，Marvin L. Minsky提出了复制算法（JavaScript 中的 Scavenge 算法就是以它为基础的改良版本）
  - 缺点：空间利用率不大，每次只能使用一次
- 1960年，George E. Collins提出了一个新的 GC 算法：引用计数
  - 缺点：不能回收“循环引用”

## 总结

## 参考资料

- [深入理解JavaScript——垃圾回收机制](https://zhuanlan.zhihu.com/p/576722965) [知乎 @Johan 约翰]
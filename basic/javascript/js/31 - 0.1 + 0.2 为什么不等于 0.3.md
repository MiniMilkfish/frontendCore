# 31 - 0.1 + 0.2 为什么不等于 0.3

```javascript
console.log(0.1 + 0.2);     // print:  0.30000000000000004
console.log(0.2 + 0.3);     // print:  0.5
```
0.1 + 0.2 为什么不等于 0.3，但是 0.2 + 0.3 = 0.5，这是为何？


## 计算机存储的模式

计算机在硬件上存储数据的时候，大家都知道是二进制 1010101010

比如说每个字节是8位，int 类型占4个字节，也就是32位精度；那么32位的计算机精度可以存2的32次方个数据，如下图：

![4个字节，64位存储](/static/ImJCa2rFz6jN5vg.png)

每个位上面可以放两个二进制数值也就是 0 或者 1；一般最高位上是符号位(1 表示负数，0 表示正数)，所以带符号类型数据应该是 31 个 2

2 _ 2 _ 2 _...... _ 2(31 个 2) ，加上符号范围就是-2147483648 ~ 2147483647；当然也有无符号整型，暂不讨论；

小数在计算机当中叫浮点型，JS 最终会由浏览器引擎转成 C++，但是 js 当中只有一种数值类型，那就是 number

## IEEE 754 浮点数的演算

我们知道，科学计数法中 30000 可以写成 3x10^4，，以 10 为底数 4 为指数的科学计数法。在 IEEE754 标准中是比较类似的，只不过它是二进制数，底数也为 2。

> IEEE 754 中最常用的浮点数值表示法是：单精确度（32位）和双精确度（64位），JavaScript 采用的是后者

```javascript
// 举个例子，十进制数 150，使用双精度浮点数表示法，表示如下：
// D 表示十进制，B 表示二进制
150D = 2^8 * 0.1001011B // 后面省略了 46 个 0
```

``` Math 短除法计算
 150   余数位
÷    2
---------------
    75     0   
÷    2
---------------
    37     1
÷    2
---------------
    18     1
÷    2
---------------
     9     0
÷    2
---------------
     4     1
÷    2
---------------
     2     0
÷    2
---------------
     1     0
÷    2
---------------
     0     1
```

最后一个余数为高位值，于是拿到 150 对应的二进制数位 1001011，也就等于 2^8 * 0.1001011。

```javascript
// (0011) 表示循环
0.1D = 2^-3 * 0.110011(0011)
```

```Math
    0.1   整数位
×     2
---------------
    0.2     0 
×     2
---------------
    0.4     0   * ↓
×     2
---------------
    0.8     0 
×     2
---------------
    1.6     1 
×     2
---------------
    1.2     1
×     2
---------------
    0.4     0   * ↑
             (0011循环)
```

与整数不同的是，第一个计算得到的整数位为最高位，故 0.1 对应的二进制数为 0.000110011(0011)，也就等于 2^-3 0.1100110011(0011)。

如果一个数既包含整数部分，又包含小数部分，其表示法的计算，需要分拆为整数和小数两部分，然后相加得到结果

## IEEE754 浮点数精度丢失

IEEE754 浮点数表示法的数据格式如下图

- 第一部分：符号位(S)，占 1 位即第 63 位；
- 第二部分：指数域(E)，占 11 位即第 52 位到 62 位，含 52 和 62；
- 第三部分：尾数域(F)，占 52 位即第 0 位到 51 位，含 51；

![双精度类型 64 位存储](/static/bFDXJ3NcyMk6lgm.png)

从上面小数的乘二取整演算中可以看到，有些小数对应的二进制数是无法写全的，比如 0.1，而 fraction 尾数部分有要求，只允许 52 位，超过部分进一舍零。

因此：

```Math
0.1D 
= 2^-4 * 1.10011(0011)B
= 2^-4 * 1.10011(0011 repeat 12 times)0011B // ← 最后一位为 1，进 1
= 2^-4 * 1.10011(0011 repeat 12 times)010B
```

## 揭秘 0.1 + 0.2

```javascript
0.1D = 2^-4 * 1.1001100110011001100110011001100110011001100110011010B
0.2D = 2^-3 * 1.1001100110011001100110011001100110011001100110011010B
0.3D = 2^-2 * 1.0011001100110011001100110011001100110011001100110011B
```

0.1 + 0.2 时，先将两者指数统一为 -3，故 0.1 小数点向左移一位，于是：

```Math
   0.1100110011001100110011001100110011001100110011001101B
+  1.1001100110011001100110011001100110011001100110011010B
------------------------------------------------------------
= 10.0110011001100110011001100110011001100110011001100111B
```

得到二进制为： 10.0110011001100110011001100110011001100110011001100111B

小数点往左移一位使得整数部分为 1，此时尾数部分为 53 位，进一舍零，于是得到最后的值是：

2^-2 * 1.0011001100110011001100110011001100110011001100110100

这个值转化成真值，结果为：0.30000000000000004。那么 0.1 + 0.2 = 0.30000000000000004 的推演到这里就结束了
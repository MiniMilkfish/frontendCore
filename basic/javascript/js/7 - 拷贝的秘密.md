# 7 - 拷贝的秘密

JavaScript的数据类型分为基本类型和引用类型

基本类型是“轻量”的，存在栈内存中； 引用类型比较重，存在堆内存中。

基本类型拷贝时，能直接拷贝； 引用类型拷贝时，拷贝的不是对象（引用类型有且只有一个数据类型 —— 对象），而是该对象在内存中的地址

JavaScript 没有不可变数据结构，不可变数据结构是函数式编程中必备的

可变数据结构的好处是节省内存或是利用可变性做一些事情，但是在复杂的开发中它的副作用远比好处大得多，于是就有了浅拷贝和深拷贝

## 对象为什么是拷贝地址

性能（节省内存）。试想如果每个对象都是拷贝值，那对象一大/多，占用的内存就会几何上升

## 如何拷贝对象的值

- Object.assign - 浅拷贝
- 扩展运算符（...） - 浅拷贝
- slice（数组方法） - 浅拷贝
- concat（数组方法）- 浅拷贝
- JSON.stringify  - 深拷贝

## 深拷贝、浅拷贝

### 深拷贝

整个对象拷贝到另一个内存中，修改内容互不影响

### 浅拷贝

浅拷贝时创建一个新对象，这个对象对原始对象属性值进行复制

- 属性是基础类型
  - 拷贝的就是基本类型的值，修改内容不影响
- 属性是引用类型
  - 拷贝的就是内存地址，修改内容互相影响

说直白点，浅拷贝只能拷贝一层，深拷贝能直接复制对象

## 拷贝1 ———— Object.assign (ES6 对象新增的方法)，浅拷贝

Object.assign() 方法可以把任意多个原对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。它拷贝的是对象的属性的引用，而非对象本身

### 参数

- target：目标对象
- souces：任意多个原对象
- 返回值：目标对象会被返回
- 适用对象：Object

```javascript
var obj1 = {a: 10, b: 20, c: 30};
var obj2 = Object.assign({}, obj1);
obj2.b = 100;

console.log(obj1); // print: {a: 10, b: 20, c: 30}
console.log(obj2); // print: {a: 10, b:100, c: 30}
```

```javascript
var obj = { a: { a: 'hello', b: 21 }};
var initialObj = Object.assign({}, obj);

initialObj.a.a = 'changed";
console.lo(obj.a.a);            // print： changed
``````

## 拷贝2 ———— 扩展运算符（...），浅拷贝

### 适用对象： Object/Array

```javascript

// 一维数组
var arr = [1, 2, 3];
var arr2 = [...arr];
arr2.push(4);
console.log(arr1);  // print: [1, 2, 3]
console.log(arr2);) // print: [1, 2, 3, 4]

// 多维数组
var a = [[1,2],[3,4],[5,6]];
var b = [...a];
b.shift().shift();

console.log(a); // print: [ [ 2 ], [ 3, 4 ], [ 5, 6 ] ]
console.log(b); // print: [ [ 3, 4 ], [ 5, 6 ] ]
```

## 拷贝3 ———— slice， 浅拷贝

## 拷贝4 ———— JSON.stringify，深拷贝


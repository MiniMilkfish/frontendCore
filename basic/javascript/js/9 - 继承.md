# 9 - 继承

> 实例.__proto__ === 构造函数.prototype

## 原型链继承

```javascript
function Person(){
    this.brain = 'smart';
}

Person.prototype.getBrain = function(){ 
    console.log(this.brain);
}

Person.prototype.age = 100;
Person.prototype.like = {
    color: 'red',
}

function JoestarFamily( name){
    this.name = name;
    this.sayName = function(){ 
        console.log(this.name);
    };
 }

 JoestarFamily.prototype = new Person();

 JoestarFamily.prototype.constructor = JoestarFamily;

 var johnny = new JoestarFamily('johnny');
 var elaine = new JoestarFamily('elaine');

 console.log(johnny, elaine);
```
![原型链继承](/static/WX_20231011184417.png)


![原型链继承原型链结构](/static/v2-f5c1642894ea26f4e4af168f9ce40074_r.jpg)

```javascript
// ... 接上文code
johnny.age = 1;
console.log(johnny.age);    // print: 1
console.log(elaine.age);    // print: 100

johnny.like.color = 'yellow';
console.log(johnny.like.color); // print: yellow
console.log(elaine.like.color); // print: yellow
```

### 优点
- 父类/父类原型新增属性和方法，子类实例可访问
- 简单，易于实现

### 缺点
- 无法实现多继承
- 原型对象的引用属性都被多个实例共享，不管是私有还是共有属性
- 创建子类实例，无法像父类构造函数传参

### 原型为什么要指回构造器

如果不加 `JoestarFamily.prototype.constructor = JoestarFamily;` 这句，将 `JoestarFamily.prototype` 的构造器属性指向自身，那么 `JoestarFamily.prototype` 的构造器将指向 `Person`

则，原型链结构图如下：

![原型为什么要指回构造器](/static/v2-b3d08d017a4dcc6e930b3110234841e5_r.jpg) 

## 借用构造函数继承（经典继承）

在子类的构造函数中通过 call/apply 之类的方法调用父类的构造函数，使父类所有属性和方法都作用在实例上。

```javascript
function Person(brain) {
    this.brain = brain;

    this.others = {
        other1: 1,
        other2: 2
    };

    this.setBrain = function(){
        console.log('set brain');
    }
}

Person.prototype.getBrain = function(){
    console.log( this.brain);
}

Person.prototype.age = 100;
Person.prototype.like = { color: 'red'};

function JoestarFamily(name) {
    this.name = name;
    this.sayName = function(){ console.log(this.name); }

    Person.call(this, 'smart');

    // Person.call(this, 'smart'); => 等同
    // this.brain = 'smart';
    // this.others = { other1: 1, other2: 2}
    // this.setBrain = function(){ console.log('set brain') }
}

var johnny = new JoestarFamily('johnny');
var elaine = new JoestarFamily('elaine');

console.log(johnny, elaine);
```
![借用构造函数继承](/static/WX_20231012121421.png)

![借用构造函数继承原型链结构](/static/v2-a63190db83e9311e9ae9c79ea2fbc104_r.jpg)

call/apply 作用是修改this的指向，拿到（非继承）Person的属性和方法给实例，但无法继承Person.prototype 上的属性和方法

```javascript
// ... 接上文
johnny.others.other1 = 123;
console.log(johnny.others.other1);  // print: 123
console.log(elaine.others.other1);  // print: 1

johnny.getBrain();  // print: Uncaught TypeError: johnny.getBrain is not a function
console.log(johnny.age);    // print: undefined

```

> 注意：所谓继承，是继承父类属性和方法。如果你在子类原型上添加对象属性，并修改对象属性中的某值，照样会影响所有的实例


### 借用函数构造继承 —— 优点

- 解决了原型链中子类实例共享父类引用属性的问题
- 创建子类实例，可以向父类传递参数
- 可以实现多继承（call 多个父类对象）

### 借用函数构造继承 —— 缺点

- 实例并不是父类的实例，只是子类的实例
  - 即 johnny instancoeof JoestarFamily => true 
  - johnny instanceof Person => false
  - 因为只是借用父类的函数和方法而非继承它
- 只能继承父类的属性和方法，不能继承父类原型属性和方法
- 占用内存，每个子类都有父类的属性和方法（一摸一样），影响性能

## 原型链 + 借用构造函数的组合继承

既想使用原型链（提供公共方法至原型上， 减少内存开销），又想让实例调用原型对象属性时不影响其他实例

```javascript
function Person(brain) {
    this.brain = brain;

    this.others = {
        other1: 1,
        other2: 2
    };

    this.setBrain = function(){
        console.log('set brain');
    }
}

Person.prototype.getBrain = function(){
    consle.log(this.brain)
}

Person.prototype.age = 100;
Person.prototype.like = { color: 'red'};

function JoestarFamily(name) {
    this.name = name;
    this.sayName = function() {
        console.log(this.name)
    }

    Person.call(this, name);
}

JoestarFamily.prototype = new Person();
JoestarFamily.prototype.constructor = JoestarFamily;

JoestarFamily.prototype.sayHello = function(){}

var johnny = new JoestarFamily('johnny');
var elaine = new JoestarFamily('elaine');

console.log(johnny, elaine);
```

![原型链 + 借用构造函数的组合继承](/static/WX_20231013172640.png)

![原型链 + 借用构造函数的组合继承原型链关系图](/static/v2-eea731e00893502efed8d338c7df7d0e_r.jpg)

### 原型链 + 借用构造函数的组合继承 —— 优点

- 可以继承父类的属性和方法，也可以继承父类原型的属性和方法
- 不存在引用数据共享问题
- 可以传参给父类构造函数
- 函数可以复用

### 原型链 + 借用构造函数的组合继承 —— 缺点

- 调用了两次构造函数，生成了两份实例（造成不必要的内存开销）

## 原型式继承

### Object.create

### Object.setPrototypeOf

## 寄生式继承

## 寄生组合式继承

## 类继承
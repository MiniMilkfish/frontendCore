# 9 - 继承

> 实例.__proto__ === 构造函数.prototype

## 原型链继承

```javascript
function Person(){
    this.brain = 'smart';
}

Person.prototype.getBrain = function(){ 
    console.log(this.brain);
}

Person.prototype.age = 100;
Person.prototype.like = {
    color: 'red',
}

function JoestarFamily( name){
    this.name = name;
    this.sayName = function(){ 
        console.log(this.name);
    };
 }

 JoestarFamily.prototype = new Person();

 JoestarFamily.prototype.constructor = JoestarFamily;

 var johnny = new JoestarFamily('johnny');
 var elaine = new JoestarFamily('elaine');

 console.log(johnny, elaine);
```
![原型链继承](/static/WX_20231011184417.png)


![原型链继承原型链结构](/static/v2-f5c1642894ea26f4e4af168f9ce40074_r.jpg)

```javascript
// ... 接上文code
johnny.age = 1;
console.log(johnny.age);    // print: 1
console.log(elaine.age);    // print: 100

johnny.like.color = 'yellow';
console.log(johnny.like.color); // print: yellow
console.log(elaine.like.color); // print: yellow
```

### 优点
- 父类/父类原型新增属性和方法，子类实例可访问
- 简单，易于实现

### 缺点
- 无法实现多继承
- 原型对象的引用属性都被多个实例共享，不管是私有还是共有属性
- 创建子类实例，无法像父类构造函数传参

## 原型为什么要指回构造器

如果不加 `JoestarFamily.prototype.constructor = JoestarFamily;` 这句，将 `JoestarFamily.prototype` 的构造器属性指向自身，那么 `JoestarFamily.prototype` 的构造器将指向 `Person`

则，原型链结构图如下：

![原型为什么要指回构造器](/static/v2-b3d08d017a4dcc6e930b3110234841e5_r.jpg) 

## 借用构造函数继承（经典继承）

在子类的构造函数中通过 call/apply 之类的方法调用父类的构造函数，使父类所有属性和方法都作用在实例上。

```javascript
function Person(brain) {
    this.brain = brain;

    this.others = {
        other1: 1,
        other2: 2
    };

    this.setBrain = function(){
        console.log('set brain');
    }
}

Person.prototype.getBrain = function(){
    console.log( this.brain);
}

Person.prototype.age = 100;
Person.prototype.like = { color: 'red'};

function JoestarFamily(name) {
    this.name = name;
    this.sayName = function(){ console.log(this.name); }

    Person.call(this, 'smart');

    // 等同
    // this.brain = 'smart';
    // this.others = { other1: 1, other2: 2}
    // this.setBrain = function(){ console.log('set brain') }
}

var johnny = new JoestarFamily('johnny');
var elaine = new JoestarFamily('elaine');

console.log(johnny, elaine);
```
![借用构造函数继承](/static/WX_20231012121421.png)

![借用构造函数继承原型链结构](/static/v2-a63190db83e9311e9ae9c79ea2fbc104_r.jpg)

call/apply 作用是为了修改this的指向
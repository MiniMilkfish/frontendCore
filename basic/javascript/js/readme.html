<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TEST</title>
</head>

<body>
    <script>
        // function shallowClone(source) {
        //     if (typeof source === 'object' && source !== null) {
        //         var target = Array.isArray(source) ? [] : {};
        //         for (let prop in source) {
        //             if (source.hasOwnProperty(prop)) {
        //                 target[prop] = source[prop];
        //             }
        //         }
        //         return target;
        //     } else {
        //         return source;
        //     }
        // }


        // function deepClone(source) {
        //     // 针对基本数据类型
        //     if (typeof source !== 'object' || source === null) return source;

        //     let target = Array.isArray(source) ? [] : {};

        //     for (let prop in source) {
        //         if (source.hasOwnProperty(prop)) {
        //             target[prop] = typeof source[prop] === 'object' ? deepClone(source[prop]) : source[prop];
        //         }
        //     }

        //     return target;
        // }

        // function deepClone(source, storage = new WeakMap()) {
        //     // 针对基本数据类型
        //     if (typeof source !== 'object' || source === null) return source;

        //     // 是否是日期
        //     if (source.constructor === Date) return new Date(source);

        //     // 是否是正则
        //     if (source.constructor === RegExp) return new RegExp(source);

        //     // 是否是数组
        //     let target = source instanceof Array ? [] : {};

        //     // 循环引用 返回存储的引用数据
        //     if (storage.has(source)) return storage.get(source);

        //     // 开辟存储空间设置临时存储值
        //     storage.set(source, target);

        //     // 是否包含 Symbol类型
        //     let isSymbol = Object.getOwnPropertySymbols(source)

        //     // 包含Symbol
        //     if (isSymbol.length) {
        //         isSymbol.forEach(item => {
        //             if (typeof source[item] === 'object') {
        //                 target[item] = deepClone(source[item], storage);
        //                 return;
        //             }
        //             target[item] = source[item];
        //         });
        //     }

        //     // 不包含 Symbol
        //     for (let key in source) {
        //         if (source.hasOwnProperty(key)) {
        //             target[key] = typeof source[key] === 'object' ? deepClone(source[key], storage) : source[key];
        //         }
        //     }

        //     return target;
        // }

        // // 构造函数
        // function Person(name) { this.name = name; }

        // const Elaine = new Person('elaine');

        // // 函数
        // function say() { console.log('hi') }

        // const arr = [1, 2 , 3, 4, {value: 5}];

        // const oldObj = {
        //     a: say,
        //     b: new Array(2),
        //     c: new RegExp('ab+c', 'i'),
        //     d: Elaine,
        //     e: arr,
        // };

        // oldObj.f = oldObj;  // 循环引用

        // console.log(oldObj)

        // var newObj = null;
        // // newObj = shallowClone(oldObj);
        // // newObj = JSON.parse(JSON.stringify(oldObj));
        // newObj = deepClone1(oldObj);

        // newObj.e[4].value = 555;

        // // 无法复制函数
        // console.log(newObj.a, oldObj.a); // undefined [Function: say]
        // // 稀疏数组复制错误
        // console.log(newObj.b[0], oldObj.b[0]); // null undefined
        // // 无法复制正则对象
        // console.log(newObj.c, oldObj.c); // {} /ab+c/i
        // // 构造函数指向错误
        // console.log(newObj.d.constructor, oldObj.d.constructor);

        // // 二位数组
        // console.log(newObj.e[4].value, oldObj.e[4].value);

        // console.log(newObj.f, oldObj.f);




        // const oldObj1 = {};
        // oldObj1.a = oldObj1;

        // const newObj1 = deepClone(oldObj1);
        // console.log(oldObj1.a);

        // function shallowClone(target) {
        //     if (typeof target === 'object' && target !== null) {
        //         const cloneTarget = Array.isArray(target) ? [] : {};
        //         for (let prop in target) {
        //             if (target.hasOwnProperty(prop)) {
        //                 cloneTarget[prop] = target[prop];
        //             }
        //         }
        //         return cloneTarget;
        //     } else {
        //         return target;
        //     }
        // }
        // // 测试const shallowCloneObj = shallowClone(obj)shallowCloneObj === obj
        // // false，返回的是一个新对象shallowCloneObj.arr === obj.arr  // true，对于对象类型只拷贝了引用


        // //函数拷贝
        // const copyObj = (obj = {}) => {
        //     //变量先置空
        //     let newobj = null;
        //     //判断是否需要继续进行递归
        //     if (typeof (obj) == 'object' && obj !== null) {
        //         newobj = obj instanceof Array ? [] : {};
        //         //进行下一层递归克隆
        //         for (var i in obj) {
        //             newobj[i] = copyObj(obj[i])
        //         }
        //         //如果不是对象直接赋值
        //     } else newobj = obj;
        //     return newobj;
        // }

        // //模拟对象
        // let obj = {
        //     numberParams: 1,
        //     functionParams: () => {
        //         console.log('欢迎关注 Echa工程师');
        //     },
        //     objParams: {
        //         a: 1,
        //         b: 2
        //     }
        // }
        // const newObj = copyObj(obj);
        // //这样就完成了一个对象的递归拷贝
        // obj.numberParams = 100;
        // //更改第一个对象的指
        // console.log(newObj.numberParams); //输出依然是1 不会跟随obj去改变


        // const gender = {
        //     //这样就说明man就是一个独一无二的值，不用再man:'man'
        //     man: Symbol(),
        //     woman: Symbol(),
        // }

        // function isMan(sex) {
        //     switch (sex) {
        //         case gender.man:
        //             console.log('男性');
        //             break;
        //         case gender.woman:
        //             console.log('女性');
        //             break
        //         default:
        //             console.log('123')
        //             break
        //     }
        // }
        // isMan(gender.man)   //男性


        // let _password = Symbol('password');
        // const obj = {
        //     name: 'Echa',
        //     gender: 'male',
        //     [_password]: '123456'
        // };
        // for (let item in obj) {
        //     console.log(item); // print: name gender
        // }

        // console.log(Object.keys(obj));  // print: ['name', 'gender']
        // console.log(Object.values(obj));    // print: ['Echa', 'male']
        // console.log(Object.getOwnPropertyNames(obj));   // print: ['name', 'gender']
        // console.log(Object.getOwnPropertySymbols(obj)); // print: ['Symbol(password)']
        // console.log(Reflect.ownKeys(obj));  // ['name', 'gender', Symbol('password')]


        // class Song {
        //     constructor(name, artist, duration) {
        //         this.name = name;
        //         this.artist = artist;
        //         this.duration = duration;
        //     }
        // }

        // class Playlist {
        //     constructor() {
        //         this.songs = [];
        //     }

        //     addSong(song) {
        //         this.songs.push(song);
        //     }

        //     [Symbol.iterator]() {
        //         let index = 0;
        //         const songs = this.songs;
        //         return {
        //             next: () => ({
        //                 value: songs[index++],
        //                 done: index > songs.length
        //             })
        //         }
        //     }
        // }

        // const playlist = new Playlist();
        // playlist.addSong(new Song('Song 1', 'Artist 1', '3:45'));
        // playlist.addSong(new Song('Song 2', 'Artist 2', '4:20'));
        // playlist.addSong(new Song('Song 3', 'Artist 3', '5:10'));

        // for (const song of playlist) {
        //     console.log(song.name);
        // }

        // class People {
        //     constructor(name, age) {
        //         this.name = name;
        //         this.age = age;
        //     }

        //     get [Symbol.toStringTag]() {
        //         return 'People1123123';
        //     }
        // }

        // const people = new People('jack', 17);

        // console.log(people.toString());


        // class MyDateTime {
        //     constructor(year, month, day, hour = 0, minute = 0, second = 0) {
        //         this._datetime = new Date(year, month - 1, day, hour, minute, second);
        //     }
        //     [Symbol.toPrimitive](hint) {
        //         switch (hint) {
        //             case 'number':
        //                 return this._datetime.getTime();
        //             case 'string':
        //                 return this._datetime.toLocaleString();
        //             default:
        //                 return this._datetime.toString();
        //         }
        //     }
        // }
        // const myDate = new MyDateTime(2023, 4, 8, 15, 30, 0);
        // console.log(myDate); // 输出：Sat Apr 08 2023 15:30:00 GMT+0800 (中国标准时间)
        // console.log(myDate + 10000); // 输出：1699950200000
        // console.log(`${myDate}`); // 输出："2023/4/8 下午3:30:00"

        // class AsyncDataSource {
        //     constructor(data) {
        //         this._data = data;
        //     }

        //     async *[Symbol.asyncIterator]() {
        //         for (const item of this._data) {
        //             const result = await this._processAsyncData(item);
        //             yield result;
        //         }
        //     }

        //     async _processAsyncData(item) {
        //         // 模拟异步处理数据的过程
        //         return new Promise((resolve) => {
        //             setTimeout(() => {
        //                 resolve(item.toUpperCase());
        //             }, Math.random() * 1000);
        //         });
        //     }
        // }

        // async function processData() {
        //     const dataSource = new AsyncDataSource(['a', 'b', 'c', 'd', 'e']);
        //     for await (const data of dataSource) {
        //         console.log(data);
        //     }
        // }

        // processData();

        // const globalVars = {
        //     a: 10,
        //     b: 20,
        //     [Symbol.unscopables]: {
        //         b: true
        //     }
        // };

        // // with (globalVars) {
        // //     console.log(a); // 输出 10
        // //     console.log(b); // 抛出 ReferenceError
        // // }

        // console.log(globalVars.b)


        // function deepClone1(source, storage = new WeakMap()) {
        //     // 针对基本数据类型
        //     if(typeof source !== 'object' || source === null) return source;

        //     // 是否是正则
        //     if (source.constructor === RegExp) return new RegExp(source);

        //     // 是否是数组
        //     let target = source instanceof Array ? []: {};

        //     // 循环引用 返回存储的引用数据
        //     if (storage.has(source)) return storage.get(source);
        //     // 开辟存储空间设置临时存储值
        //     storage.set(source, target);

        //     let hasSymbol = Object.getOwnPropertySymbols(source);
        //     if(hasSymbol.length) {
        //         hasSymbol.forEach(item => {
        //             if(typeof source[item] === 'object') {
        //                 target[item] = deepClone(source[item], storage);
        //                 return;
        //             }

        //             target[item = source[item]];
        //         })
        //     } else {
        //         for (let key in source) {
        //             if(source.hasOwnProperty(key)) {
        //                 target[key] = typeof source[key] === 'object' ? deepClone1(source[key], storage): source[key];
        //             }
        //         }
        //     }

        //     return target
        // }


        // function Foo() { }
        // Foo.prototype.name = 'johan';
        // console.dir(Foo);
        // console.dir(Foo.prototype);

        // function Person() {
        //     this.brain = 'smart';
        // }

        // Person.prototype.getBrain = function () {
        //     console.log(this.brain);
        // }

        // Person.prototype.age = 100;
        // Person.prototype.like = {
        //     color: 'red',
        // }

        // function JoestarFamily(name) {
        //     this.name = name;
        //     this.sayName = function () {
        //         console.log(this.name);
        //     };
        // }

        // JoestarFamily.prototype = new Person();

        // // JoestarFamily.prototype.constructor = JoestarFamily;

        // var johnny = new JoestarFamily('johnny');
        // var elaine = new JoestarFamily('elaine');

        // console.log(johnny, elaine);



        // function Person(name) {
        //     this.name = name;

        //     this.printName = function () { console.log(this.name); }
        // }
        // Person.prototype.printCommon = function () { console.log('共享方法') }

        // function Student(name, score) {
        //     this.score = score;
        //     this.printScore = function () { console.log(this.score) };
        //     Person.call(this, name);
        // }

        // var F = function () { }
        // F.prototype = Person.prototype;
        // Student.prototype = new F();

        // var johnny = new Person('johnny')
        // var elaine = new Student('elaine', 99)
        // console.log(johnny, elaine);
        // console.log(johnny.printCommon === elaine.printCommon)

        function Person(brain) {
            this.brain = brain;
            this.others = { other1: 1, other2: 2 };
            this.setBrain = function () { console.log('set brain'); };
        }

        Person.prototype.getBrain = function () { console.log(this.brain); }
        Person.prototype.age = 100;
        Person.prototype.like = { color: 'red' };

        function JoestarFamily(name) {
            this.name = name;
            this.sayName = function () { console.log(this.name); };

            Person.call(this, "smart");
        }

        // #startregion 引用Object.create 的核心代码
        // 本质是不用new 的特性，而是用显式原型继承的法子，这样就不用因使用 new 而产生副作用
        // 核心代码 01
        var F = function () { }                // 创建一个空的构造函数

        // 核心代码 02
        F.prototype = Person.prototype;     // 将Person 原型赋值给空构造函数的原型，即F.prototype 拥有了 Person.prototype 上所有的属性和方法，包括 constructor, getBrain, age, like, __proto__

        JoestarFamily.prototype = new F();  // new F, 等于 JoestarFamily.prototype.__proto__ === F.prototype
        // #endregion


        JoestarFamily.prototype.constructor = JoestarFamily;

        JoestarFamily.prototype.sayHello = function () { console.log('sayHello'); };

        var johnny = new JoestarFamily('johnny');
        var elaine = new JoestarFamily('elaine');

        console.log(johnny, elaine);
    </script>
</body>

</html>